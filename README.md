# use-pointer-anywhere
练习使用指针指向各种数据类型，如整形，数组，字符，结构体，指针
先停在此处，不再往下进行，反复将之前的提交进行练习，知道稍稍动下脑子就能条件反射为止
重新书写各种数据类型在遍历时的结束判断条件，如'\0', NULL, size大小。

---------------------------------------------------------------------
专题3-4中的3， 如果不适用二维数组指针的话，比如使用a[1]作为函数参数表示第二行可以吗,请验证 ？


思考
-----------------------------------------------
http://ju.outofmemory.cn/entry/162349

首先给出结论，  sizeof 不是在编译时就定好了，需要运行
#
#C语言中 sizeof 运算的值是在编译时还是运行时确定的？
#Masking's Blog 2013-04-24 1281 阅读
#C语言
#
#在经典的《C语言程序设计》书中说到：
#
#C语言提供了一个编译时(compile-time) 一元运算符 sizeof，它可以用来计算任一对象的长度。 表达式
#
#sizeof 对象
#
#以及
#
#sizeof(类型名)
#
#	将返回一个整型值，它等于指定对象或类型占用的存储空间字节数。
#
#	当然这里显然得到结论 sizeof 的值是在编译时确定的， 可是在C99标准前这是毫无疑问的，但是C99标准引入了动态数组，比如下列代码：
#
#	// 需在C99标准的编译器下编译， ANSI C (即C89)下编译不通过
#
##include <stdio.h>
##include <stdlib.h>
#
#	int main(int argc, char *argv[]) {
#		int n;
#		scanf("%d",&n);
#		int arr[n];
#		printf("%d\n",sizeof(n++));
#		printf("%d\n",sizeof(arr));
#		printf("%d",n);
#		return 0;
#	}
#
#上述代码开始输入 3 给 n
#
#输出结果为:
#
#4 12 3
#
#即sizeof(n++)中的++未执行，(在sizeof后使用函数，同样在求函数返回值大小时，函数也不会执行)
#
#	但sizeof(arr) 一定不是在编译时确定的。 不同的输入得到动态数组大小不一；
#
#	所以觉得：
#
#	在c99没有出现之前，sizeof是由编译时确定的，
#
#	sizof对一个类型求出的值可以当一个常量来用。 但，c99中引入了动态数组（定义一个数组，其大小由运行时确定） 导致sizeof作用于动态数组时的值不再是常量
#
#	ps: sizeof(‘a’)在C语言中的结果是4，在C++中结果是1，看过某篇文章说C中sizeof侧重于“数”，而C++中sizeof更侧重于“字符”。
#
#	两个用宏实现sizeof的经典应用
#
#	//适用于非数组
#
##define _sizeof(T) ((size_t)((T*)0 + 1))
#
#	//适用于数组
#
##define array_sizeof(T) ((size_t)(&T+1)-(size_t)(&T))
#
#	对于非数组的宏定义，先是将0转换为T*类型的指针所指向的地址（此时地址为0）。然后对T类型的地址加1，相当于加上了T类型的大小（即得到了非数组T的大小）。前面的size_t只是将地址转化为int型的整数返回。 一个简单的例子：int* p; p=p+1; ——–p是一个int*类型的指针， p+1在地址空间上相当于加上了4个字节。
#
#	对于数组的宏定义，类似于非数组的宏定义，为了方便理解，这里可以把数组T看成一个用户自定义的类型，&T表示数组类型的指针，对于数组类型指针加1相当于在地址上加上了该数组大小。由于是用户自定义的类型所以不能强制将0转化为数组类型的地址，只能用加1后的地址减去之前的地址，得到的差值就是数组本身所占的字节大小。
